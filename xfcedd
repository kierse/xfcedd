#!/usr/bin/perl -w

use strict;
use IO::Socket::INET;
use POSIX;

# daemon variables
#
my %Vars = (
	"delay" => "3600",
	"time" => "",
	"file" => "",
	"directory" => "",
	"log" => 1,
	"size" => 50,
	"cache" => [],
	"version" => "0.1.1",
);
my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";

# if server is already running and user sent no arguments, exit
#
if( -e $path && (scalar @ARGV == 0) ) { exit; }

# if server is running and user is attempting to query server
#
elsif( -e $path && (scalar @ARGV > 0) )
{
	# check if user is requesting server version
	#
	if($ARGV[0] =~ /^-v$/i)
	{ 
		displayOptions();
	}
	else
	{
		# verify user didn't enter non-existent command
		# line option(s).
		#
		my ($code, $message) = checkCommandLineOptions(@ARGV);
		exit displayOptions($message) unless $code;

		# get port of running server
		#
		open(PORT, "<", $path);
		my $port = <PORT>;
		close(PORT);
	
		# open a socket to running server
		#
		my $socket = new IO::Socket::INET
		(
			PeerAddr => "Localhost",
			PeerPort => $port,
			Proto    => "tcp",
			Type     => SOCK_STREAM,
		) or die "Couldn't open connection to server: $!\n";
	
		# send request to server
		#
		print $socket $message;
		
		# read response and print to console
		#
		($code, $message) = split ":", <$socket>;
		print displayOptions($message) unless $code;
	
		# close socket
		#
		close($socket);
	}
}

# no server running!  Start up xfcedd daemon 
#
else
{
	# trap fatal signals and set flag indicating we need to exit gracefully
	#
	my $keep_running = 1;
	sub signal_handler { $keep_running = 0; }
#	sub alarm_handler
#	{
#		print "time to change picture!\n";
#	}
	
	# trap or ignore $SIG{PIPE}
	#
	$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signal_handler;
#	$SIG{ALRM} = \&alarm_handler;

	# verify user didn't enter non-existent command
	# line option(s).
	#
	my ($code, $message) = checkCommandLineOptions(@ARGV);
	exit displayOptions($message) unless $code;

	# update variables with command line options
	#
	updateRunTimeVariables($message, \%Vars);

#	# need to fork off child process that is
#	# not associated with the process that started the parent
#	#
#	my $pid = fork;
#	exit if $pid;
#	die "Couldn't fork: $!" unless defined($pid);
#	
#	# Dissociate from the controlling terminal that started parent
#	# and stop being part of whatever process group we had been a member of.
#	#
#	POSIX::setsid() or die "Can't start a new session: $!";
	
	# Assign a more appropriate name to running process
	# this is useful in that the running process will appear 
	# as 'xfcedd' rather than '/usr/bin/perl xfcedd'
	#
	$0 = "xfcedd " . join " ", @ARGV;

	# acquire socket
	#
	my $server = new IO::Socket::INET(
		Type      => SOCK_STREAM,
		Reuse     => 1,
		Listen    => 10
	) or die "Couldn't acquire socket: $!\n";
	
	# write out temporary file with port number
	#
	my $socketPort = $server->sockport();
	my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";
	open(PORT, ">", $path);
	print PORT $socketPort;
	close(PORT);
	
	# loop and wait for a client connection
	#
	while( $keep_running && (my $client = $server->accept()) )
	{
		# get request from client
		#
		my $cmd = <$client>;
		$cmd =~ s/\n//;

		if($cmd eq "k")
		{
			$keep_running = 0;
			print $client "1\n";
		}
		else
		{
			my $result = updateRunTimeVariables($cmd, \%Vars);
			print $client $result;
		}
		
		# close client connection
		#
		close($client);
	}
	
	# delete the file pointing to the port
	#
	unlink($path);
	
	# close the open socket
	#
	close($server);
}

sub 

sub checkCommandLineOptions
{
	my (@Args) = @_;
	my @Query;

	for(my $i = 0; $i < scalar @Args; $i++)
	{
		my ($flag, $data) = ("", "");
		if($Args[$i] eq "-k")
		{ 
			return (1, "k\n");
		}
		elsif($Args[$i] eq "-v")
		{ 
			# this is empty on purpose #
		}
		elsif($Args[$i] eq "-t")
		{
			$flag = "t";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number\n") unless $data =~ /^\d+$/;
		}
		elsif($Args[$i] eq "-f")
		{
			$flag = "f";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid image\n") unless $data =~ /(gif|png|jpg|jpeg)$/i;
		}
		elsif($Args[$i] eq "-d")
		{
			$flag = "d";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid directory\n") unless -d $data;
		}
		elsif($Args[$i] eq "-l")
		{
			$flag = "l";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a 0 or 1\n") unless( ($data == 0) || ($data == 1) );
		}
		elsif($Args[$i] eq "-s")
		{
			$flag = "s";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number between 0 and 100\n") unless $data >= 0;
		}
		else
		{
			return (0, "Error: Illegal value " . $Args[$i] . "\n");
		}
			
		push @Query, "$flag:$data";
	}

	return (1, join(",", @Query) . "\n");
}

sub updateRunTimeVariables
{
	my ($cmd, $Vars) = @_;
	my $update = 0;

	# if given cmd is empty, return
	#
	return if $cmd =~ /^\n?$/;

	# parse through given array and update given values
	#
	foreach my $pair (split ",", $cmd)
	{
		# split up pair into flag and data
		#
		my ($flag, $data) = split ":", $pair;
		$data =~ s/\n//;
	
		# update delay value
		if($flag eq "t")
		{ 
			$data >= 0 
				and $$Vars{"delay"} = $data 
				and $update = 1;
		}

		# update file value
		elsif($flag eq "f")
		{
			if(-e $data)
			{
				$$Vars{"file"} = $data;
				$update = 1;
			}
			elsif(-e $$Vars{"directory"} . "/" . $data)
			{
				$$Vars{"file"} = $$Vars{"directory"} . "/" . $data;
				$update = 1;
			}
		}

		# update directory value
		elsif($flag eq "d")
		{
			(-d "$data") and $$Vars{"directory"} = $data;
		}

		# update log value
		elsif($flag eq "l")
		{
			($data == 0 || $data == 1) and $$Vars{"log"} = $data;
		}

		# update max log count value
		elsif($flag eq "s")
		{
			($data >= 0 && $data <= 100) and $$Vars{"size"} = $data;
		}

		# oops, unknown command line parameter
		else 
		{ 
			return "0:Unknown parameter -$flag.\n"; 
		}
	}

	# if update flag is set, try and 
	# update desktop image
	#
	if($update)
	{
		updateDesktop($Vars);
	}

	return "1\n";
}

sub displayOptions
{
	my ($error) = @_;
	$error ||= "";
	
	# print out command line options in friendly,
	# human readable format
	# 
	print $error .
			"-----------------------------------------------------------------------------\n" .
			"xfcedd " . $Vars{"version"} . " by Kier Elliott.\n" .
			"This software comes with ABSOLUTELY NO WARRANTY.\n" .
			"Usage:  xfcedd [-k | -v | -t <time_delay> -d <image_directory> -f <file_name>\n" .
			"                          -l <boolean> -s <log_size> ]\n" . 
			"        (Put filenames or directories in single quotes (') )\n" .
			"        -k   Kill running daemon\n" .
			"        -v   Print our version information\n" .
			"        -t   Set time delay daemon waites before choosing new image\n" .
			"        -f   Set current/startup image.\n" .
			"        -d   Set current/startup image directory.\n" .
			"        -l   Turn logging on (1) or off (0).\n" .
			"        -s   Set size of log, must be between 0 and 100.\n" .
			"\n";
}

sub updateDesktop
{
	my ($Vars) = @_;

	# get new image
	#
	my $file;
	if($$Vars{"file"})
	{
		$file = $$Vars{"file"};
		$$Vars{"file"} = "";
	}
	else
	{
		$file = _chooseRandomImage($$Vars{"directory"}, $$Vars{"cache"});		
	}

	# update desktop using new image...
	#
	_refreshDesktop($file);

	# cache image selection
	#
	_updateCache($file, $$Vars{"log"}, $$Vars{"size"}, $$Vars{"cache"});

	# reset time delay counter...
	#
	_resetTimer(\$$Vars{"delay"}, \$$Vars{"time"});

	return undef;
}

sub checkTimer
{
	my ($delay, $time) = @_;

	_resetTimer($delay, $time) unless ($time > time());

	return 1;
}

sub _chooseRandomImage
{
	my ($dir, $Cache) = @_;
	my $file;
	
	# get a directory listing of all images in given directory
	# remove '.', '..', and all files that aren't gif, png, or jpg
	#
	opendir(IMAGES, $dir);
	my @Files = grep { $_ =~ /\.(gif|png|jpg|jpeg)$/i } readdir(IMAGES);
	closedir(IMAGES);

	my $max = scalar(@Files);
	if($max == 1)
	{
		$file =  $Files[0];
	}
	elsif($max > 1)
	{
		# randomly choose an image from the given directory
		# call checkCache to ensure that the image hasn't been
		# recently used...
		#
		my $count = 0;
		do
		{
			# generate a random number between 0 and max...
			#
			my $rand = rand ($max - 1);
			$file = "$dir/" . $Files[$rand];
		}
		while( _checkCache("$dir/$file", $max, $Cache) && ($count++ < $max) );
	}

	return $file;
}

sub _refreshDesktop
{
	my ($file) = @_;

	# call xfdesktop and update image
	#
	system("ln -sf \'$file\' $ENV{HOME}/.xfce4/.desktopImage");
	system("xfdesktop");

	return undef;
}

sub _checkCache
{
	my ($file, $depth, $Cache) = @_;

	for(my $i = 0; $i < scalar @{$Cache} && $i < $depth; $i++)
	{
		return 1 if $$Cache[$i] eq $file;
	}

	return 0;
}

sub _updateCache
{
	my ($file, $log, $max, $Cache) = @_;
	my $size = scalar @{$Cache};
	
	if($size > $max)
	{
		# shorten cache to equal maximum allowed size
		#
		splice(@{$Cache}, 0, ($size - $max) + 1);
	}
	elsif(scalar $size == $max)
	{
		# remove the 1st list element
		#
		shift(@{$Cache});
	}

	# push new file onto cache list
	#
	push @{$Cache}, $file;

	return undef;
}

sub _resetTimer
{
	my ($delay, $time) = @_;

	$time = time() + $delay;

	return undef;
}
