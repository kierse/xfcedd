#!/usr/bin/perl -w

use strict;
use IO::Socket::INET;
use POSIX;

# daemon variables
#
#my ($delay, $file, $dir, $log, $max_log_count) = ("", "", "", 1, 50);
my %Vars = (
	"time" => "",
	"file" => "",
	"directory" => "",
	"log" => 1,
	"size" => 50,
	"cache" => [],
	"version" => "0.1.0",
);
my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";

# if server is already running and user sent no arguments, exit
#
if( -e $path && (scalar @ARGV == 0) ) { exit; }

# if server is running and user is attempting to query server
#
elsif( -e $path && (scalar @ARGV > 0) )
{
	# check if user is requesting server version
	#
	if($ARGV[0] =~ /^-v$/i)
	{ 
		displayOptions();
	}
	else
	{
		# verify user didn't enter non-existent command
		# line option(s).
		#
		my ($code, $message) = checkCommandLineOptions(@ARGV);
		exit displayOptions($message) unless $code;

		# get port of running server
		#
		open(PORT, "<", $path);
		my $port = <PORT>;
		close(PORT);
	
		# open a socket to running server
		#
		my $socket = new IO::Socket::INET
		(
			PeerAddr => "Localhost",
			PeerPort => $port,
			Proto    => "tcp",
			Type     => SOCK_STREAM,
		) or die "Couldn't open connection to server: $!\n";
	
		# send request to server
		#
		print $socket $message;
		
		# read response and print to console
		#
		($code, $message) = split ":", <$socket>;
		print displayOptions($message) unless $code;
	
		# close socket
		#
		close($socket);
	}
}

# no server running!  Start up xfcedd daemon 
#
else
{
	# trap fatal signals and set flag indicating we need to exit gracefully
	#
	my $keep_running = 1;
	sub signal_handler { $keep_running = 0; }
	
#	sub alarm_handler
#	{
#		print "time to change picture!\n";
#	}
	
	# trap or ignore $SIG{PIPE}
	#
	$SIG{INT} = $SIG{TERM} = $SIG{HUP} = \&signal_handler;
#	$SIG{ALRM} = \&alarm_handler;

#	alarm(10);

	# verify user didn't enter non-existent command
	# line option(s).
	#
	my ($code, $message) = checkCommandLineOptions(@ARGV);
	exit displayOptions($message) unless $code;

	# update variables with command line options
	#
	updateRunTimeVariables($message, \%Vars);


			print "time: " . $Vars{"time"} . "\n" .
					"file: " . $Vars{"file"} . "\n" .
					"dir: " .  $Vars{"directory"} . "\n" .
					"log: " . $Vars{"log"} . "\n" .
					"max_log_count: " . $Vars{"size"} . "\n";
#	# need to fork off child process that is
#	# not associated with the process that started the parent
#	#
#	my $pid = fork;
#	exit if $pid;
#	die "Couldn't fork: $!" unless defined($pid);
#	
#	# Dissociate from the controlling terminal that started parent
#	# and stop being part of whatever process group we had been a member of.
#	#
#	POSIX::setsid() or die "Can't start a new session: $!";
	
	# acquire socket
	#
	my $server = new IO::Socket::INET(
		Type      => SOCK_STREAM,
		Reuse     => 1,
		Listen    => 10
	) or die "Couldn't acquire socket: $!\n";
	
	# write out temporary file with port number
	#
	my $socketPort = $server->sockport();
	my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";
	open(PORT, ">", $path);
	print PORT $socketPort;
	close(PORT);
	
	# loop and wait for a client connection
	#
	while( $keep_running && (my $client = $server->accept()) )
	{
		# $client is the new connection...
		#
		#my $socket_address = $client->sockname();
		#my ($port, $myaddr)   = sockaddr_in($socket_address);

		# get request from client
		#
		my $cmd = <$client>;
	
		print "Client request: $cmd";
		$cmd =~ s/\n//;
		if($cmd eq "k")
		{
			$keep_running = 0;
			print $client "1\n";
		}
		else
		{
			my $result = updateRunTimeVariables($cmd, \%Vars);
			print $client $result;
			
			print "time: " . $Vars{"time"} . "\n" .
					"file: " . $Vars{"file"} . "\n" .
					"dir: " .  $Vars{"directory"} . "\n" .
					"log: " . $Vars{"log"} . "\n" .
					"max_log_count: " . $Vars{"size"} . "\n";
		}
		
		# close client connection
		#
		close($client);
	}
	
	# delete the file pointing to the port
	#
	unlink($path);
	
	# close the open socket
	#
	close($server);
}

sub checkCommandLineOptions
{
	my (@Args) = @_;
	my @Query;

	for(my $i = 0; $i < scalar @Args; $i++)
	{
		my ($flag, $data) = ("", "");
		if($Args[$i] eq "-k")
		{ 
			return (1, "k\n");
		}
		elsif($Args[$i] eq "-v")
		{ 
			# this is empty on purpose #
		}
		elsif($Args[$i] eq "-t")
		{
			$flag = "t";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number\n") unless $data =~ /^\d+$/;
		}
		elsif($Args[$i] eq "-f")
		{
			$flag = "f";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid image\n") unless $data =~ /^\w+\.(gif|png|jpg|jpeg)$/i;
		}
		elsif($Args[$i] eq "-d")
		{
			$flag = "d";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid directory\n") unless -d $data;
		}
		elsif($Args[$i] eq "-l")
		{
			$flag = "l";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a 0 or 1\n") unless( ($data == 0) || ($data == 1) );
		}
		elsif($Args[$i] eq "-s")
		{
			$flag = "s";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number between 0 and 100\n") unless $data >= 0;
		}
		else
		{
			return (0, "Error: Illegal value " . $Args[$i] . "\n");
		}
			
		push @Query, "$flag:$data";
	}

	return (1, join(",", @Query) . "\n");
}

sub displayOptions
{
	my ($error) = @_;
	$error ||= "";
	
	# print out command line options in friendly,
	# human readable format
	# 
	print $error .
			"-----------------------------------------------------------------------------\n" .
			"xfcedd " . $Vars{"version"} . " by Kier Elliott.\n" .
			"This software comes with ABSOLUTELY NO WARRANTY.\n" .
			"Usage:  xfcedd [-k | -v | -t <time_delay> -f <file_name> -d <image_directory>\n" . 
			"        (Put filenames or directories in single quotes (') )\n" .
			"        -k   Kill running daemon\n" .
			"        -v   Print our version information\n" .
			"        -t   Set time delay daemon waites before choosing new image\n" .
			"        -f   Set current/startup image.\n" .
			"        -d   Set current/startup image directory.\n" .
			"\n";
}

sub updateRunTimeVariables
{
	my ($cmd, $Vars) = @_;

	# parse through given array and update given values
	#
	#for(my $i = 0; $i < scalar @{$Args}; $i++)
	foreach my $pair (split ",", $cmd)
	{
		# split up pair into flag and data
		#
		my ($flag, $data) = split ":", $pair;

		$data =~ s/\n//;
	
		# update delay value
		if($flag eq "t")
		{ 
			$data >= 0 and $$Vars{"time"} = $data;
		}

		# update file value
		elsif($flag eq "f")
		{
			$data =~ /^\w+\.(gif|png|jpg|jpeg)$/i and $$Vars{"file"} = $data;
		}

		# update directory value
		elsif($flag eq "d")
		{
			(-d "$data") and $$Vars{"directory"} = $data;
		}

		# update log value
		elsif($flag eq "l")
		{
			($data == 0 || $data == 1) and $$Vars{"log"} = $data;
		}

		# update max log count value
		elsif($flag eq "s")
		{
			($data >= 0 && $data <= 100) and $$Vars{"size"} = $data;
		}

		# oops, unknown command line parameter
		else 
		{ 
			return "0:Unknown parameter -$flag.\n"; 
		}
	}

	return "1\n";
}

sub chooseRandomImage
{
	my ($dir, $Cache) = @_;
	my $file;
	
	# get a directory listing of all images in given directory
	# remove '.', '..', and all files that aren't gif, png, or jpg
	#
	open(IMAGES, "<", $dir);
	my @Files = grep { $_ =! /\.|\.\./ and $_ =~ /^\w+\.(gif|png|jpg|jpeg)$/i } readdir(IMAGES);
	close(IMAGES);

	my $max = scalar(@Files) - 1;
	if($max == 1)
	{
		$file =  $Files[0];
	}
	elsif($max > 1)
	{
		# randomly choose an image from the given directory
		# call checkCache to ensure that the image hasn't been
		# recently used...
		#
		my $count = 0;
		do
		{
			# generate a random number between 0 and max...
			#
			my $rand = rand $max;
			$file = "$dir/" . $Files[$rand];
		}
		while( checkCache("$dir/$file", $max, $Cache) || ($count++ < $max) );
	}

	return $file;
}

sub updateDesktop
{
	my ($file) = @_;

	# call xfdesktop and update image
	#
	system("ln -sf $file $ENV{HOME}/.xfce4/.desktopImage");
	system("xfdesktop");
}

sub checkCache
{
	my ($file, $depth, $Cache) = @_;

	for(my $i = 0; $i < scalar @{$Cache} && $i < $depth; $i++)
	{
		return 0 if $$Cache[$i] eq $file;
	}

	return 0;
}

sub updateCache
{
	my ($file, $max, $Cache) = @_;
	
	my $size = scalar @{$Cache};
	if($size > $max)
	{
		# shorten cache to equal maximum allowed size
		#
		splice(@{$Cache}, 0, ($size - $max) + 1);
	}
	elsif(scalar @{$Cache} == $size)
	{
		# remove the 1st list element
		#
		shift(@{$Cache});
	}

	# push new file onto cache list
	#
	push @{$Cache}, $file;
}
