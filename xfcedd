#!/usr/bin/perl -w

#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#
#   Application:    xfcedd (Xfce Desktop Daemon)
#
#   Author:         Kier Elliott
#
#   Date:           01/02/2005
#
#   Description:    The xdce desktop daemon was designed to add a 
#                   little flavor to the xfce desktop.  It allows a user
#                   to specify a directory of desktop images to choose
#                   from.  The Daemon will then randomly select an image
#                   (after a specified delay) and update the Xfce desktop.
#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#
#
#   Subversion Info:
#     $LastChangedBy$
#     $Date$
#     $Rev$
#     $URL$
#
#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

use strict;
use POSIX;
use IO::Socket::INET;

# daemon variables
#
my %Vars = (
	"delay" => "3600",
	"file" => "",
	"directory" => "",
	"log" => 1,
	"size" => 50,
	"cache" => [],
	"version" => "0.2.1",
);

my $version = "0.2.0";
my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";
my $log_file = $ENV{'HOME'} . "/.xfce4/xfcedd.log";

# if server is already running and user sent no arguments, exit
#
if( -e $path && (scalar @ARGV == 0) ) { exit; }

# if server is running and user is attempting to query server
#
elsif( -e $path && (scalar @ARGV > 0) )
{
	# check if user is requesting server version
	#
	if($ARGV[0] =~ /^-v$/i)
	{ 
		displayOptions();
	}
	else
	{
		# verify user didn't enter non-existent command
		# line option(s).
		#
		my ($code, $message) = checkCommandLineOptions(@ARGV);
		exit displayOptions($message) unless $code;

		# get port of running server
		#
		open(PORT, "<", $path);
		my $port = <PORT>;
		close(PORT);
	
		# open a socket to running server
		#
		my $socket = new IO::Socket::INET
		(
			PeerAddr => "Localhost",
			PeerPort => $port,
			Proto    => "tcp",
			Type     => SOCK_STREAM,
		) or die "Couldn't open connection to server: $!\n";
	
		# send request to server
		#
		print $socket $message;
		
		# read response and print to console
		#
		($code, $message) = split ":", <$socket>;
		print displayOptions($message) unless $code;
	
		# close socket
		#
		close($socket);
	}
}

# no server running!  Start up xfcedd daemon 
#
else
{
	require Event::Lib;
	Event::Lib->import();
	
	# verify user didn't enter non-existent command
	# line option(s).
	#
	my ($code, $message) = checkCommandLineOptions(@ARGV);
	exit displayOptions($message) unless $code;

	# update variables with command line options
	#
	updateRunTimeVariables($message, \%Vars);

	# need to fork off child process that is
	# not associated with the process that started the parent
	#
	my $pid = fork;
	exit if $pid;
	die "Couldn't fork: $!" unless defined($pid);
	
	# Dissociate from the controlling terminal that started parent
	# and stop being part of whatever process group we had been a member of.
	#
	POSIX::setsid() or die "Can't start a new session: $!";
	
	# must register events with Event::Lib
	#
	event_init();

	# Assign a more appropriate name to running process
	# this is useful in that the running process will appear 
	# as 'xfcedd' rather than '/usr/bin/perl xfcedd'
	#
	$0 = "xfcedd " . join " ", @ARGV;

	# acquire socket
	#
	my $server = new IO::Socket::INET(
		Type      => SOCK_STREAM,
		Reuse     => 1,
		Listen    => 10
	) or die "Couldn't acquire socket: $!\n";
	
	# write out temporary file with port number
	#
	my $socketPort = $server->sockport();
	my $path = $ENV{'HOME'} . "/.xfce4/.xfcedd=";
	open(PORT, ">", $path);
	print PORT $socketPort;
	close(PORT);
	
	# create event watchers...
	#
	my %Events;
	%Events = (
		"main"  => event_new($server, Event::Lib->EV_READ(), \&clientHandler, \%Events, \%Vars),
   	"timer" => timer_new(sub { timerHandler(\%Events, \%Vars); }),
   	"int"   => signal_new(SIGINT, sub { terminateEventWatchers(\%Events); }),
   	"term"  => signal_new(SIGTERM, sub { terminateEventWatchers(\%Events); }),
   	"hup"   => signal_new(SIGHUP, sub { terminateEventWatchers(\%Events); }),
	);
   
	# ...and add them to the event loop
	#
   $_->add for values %Events;

	# start event loop!
	#
   $Events{"main"}->dispatch;	

	# delete the file pointing to the port
	#
	unlink($path);
	
	# close the open socket
	#
	close($server);
}

sub clientHandler
{
	my ($e, $type, $Events, $Vars) = @_;
	my $socket = $e->fh();
	my $client = $socket->accept();

	# get request from client
	#
	my $cmd = <$client>;
	$cmd =~ s/\n//;

	if($cmd eq "k")
	{
		print $client "1\n";
		terminateEventWatchers($Events);
	}
	else
	{
		my $result = updateRunTimeVariables($cmd, $Vars);
		print $client $result;

		timerHandler($Events, $Vars);
	}
	
	# close client connection
	#
	close($client);

	# add the event listener, have to do this or
	# listener will only work once!
	#
	$e->add();
}

sub timerHandler
{
	my ($Events, $Vars) = @_;

	$$Events{"timer"}->del();
	if($$Vars{"delay"} > 0)
	{
		$$Events{"timer"}->add($$Vars{"delay"});
	}

	# update display!
	#
	updateDesktop($Events, $Vars);
}

sub terminateEventWatchers
{
	my ($Events) = @_;

	foreach my $event (values %{$Events})
	{
		$event->del();
	}
}

sub checkCommandLineOptions
{
	my (@Args) = @_;
	my @Query;

	for(my $i = 0; $i < scalar @Args; $i++)
	{
		my ($flag, $data) = ("", "");
		if($Args[$i] eq "-k")
		{ 
			return (1, "k\n");
		}
		elsif($Args[$i] eq "-v")
		{ 
			# this is empty on purpose #
		}
		elsif($Args[$i] eq "-t")
		{
			$flag = "t";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number\n") unless $data =~ /^\d+$/;
		}
		elsif($Args[$i] eq "-f")
		{
			$flag = "f";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid image\n") unless $data =~ /(gif|png|jpg|jpeg)$/i;
		}
		elsif($Args[$i] eq "-d")
		{
			$flag = "d";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a valid directory\n") unless -d $data;
		}
		elsif($Args[$i] eq "-l")
		{
			$flag = "l";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a 0 or 1\n") unless( ($data == 0) || ($data == 1) );
		}
		elsif($Args[$i] eq "-s")
		{
			$flag = "s";
			$data = $Args[++$i];
			return (0, "Error: Illegal value $data - must be a number between 0 and 100\n") unless $data >= 0;
		}
		else
		{
			return (0, "Error: Illegal value " . $Args[$i] . "\n");
		}
			
		push @Query, "$flag:$data";
	}

	return (1, join(",", @Query) . "\n");
}

sub updateRunTimeVariables
{
	my ($cmd, $Vars) = @_;

	# if given cmd is empty, return
	#
	return if $cmd =~ /^\n?$/;

	# parse through given array and update given values
	#
	foreach my $pair (split ",", $cmd)
	{
		# split up pair into flag and data
		#
		my ($flag, $data) = split ":", $pair;
		$data =~ s/\n//;
	
		# update delay value
		if($flag eq "t")
		{ 
			$data >= 0 and $$Vars{"delay"} = $data;
		}

		# update file value
		elsif($flag eq "f")
		{
			if(-e $data)
			{
				$$Vars{"file"} = $data;
			}
			elsif(-e $$Vars{"directory"} . "/" . $data)
			{
				$$Vars{"file"} = $$Vars{"directory"} . "/" . $data;
			}
		}

		# update directory value
		elsif($flag eq "d")
		{
			(-d "$data") and $$Vars{"directory"} = $data;
		}

		# update log value
		elsif($flag eq "l")
		{
			($data == 0 || $data == 1) and $$Vars{"log"} = $data;
		}

		# update max log count value
		elsif($flag eq "s")
		{
			($data >= 0 && $data <= 100) and $$Vars{"size"} = $data;
		}

		# oops, unknown command line parameter
		else 
		{ 
			return "0:Unknown parameter -$flag.\n"; 
		}
	}

	return "1\n";
}

sub displayOptions
{
	my ($error) = @_;
	$error ||= "";
	
	# print out command line options in friendly,
	# human readable format
	# 
	print $error .
			"-----------------------------------------------------------------------------\n" .
			"xfcedd " . $version . " by Kier Elliott.\n" .
			"This software comes with ABSOLUTELY NO WARRANTY.\n" .
			"Usage:  xfcedd [-k | -v | -t <time_delay> -d <image_directory> -f <file_name>\n" .
			"                          -l <boolean> -s <log_size> ]\n" . 
			"   (Put filenames or directories in single quotes (') )\n" .
			"   -k   Kill running daemon\n" .
			"   -v   Print our version information\n" .
			"   -t   Set time delay (in seconds) daemon waits before choosing new image\n" .
			"   -f   Set current/startup image.\n" .
			"   -d   Set current/startup image directory.\n" .
			"   -l   Turn logging on (1) or off (0).\n" .
			"   -s   Set size of log, must be between 0 and 100.\n" .
			"\n";
}

sub updateDesktop
{
	my ($Events, $Vars) = @_;

	# get new image
	#
	my $file;
	if($$Vars{"file"})
	{
		$file = $$Vars{"file"};
		$$Vars{"file"} = "";
	}
	else
	{
		$file = _chooseRandomImage($$Vars{"directory"}, $$Vars{"cache"});		
	}

	# update desktop using new image...
	#
	_refreshDesktop($file);

	# cache image selection
	#
	_updateCache($file, $$Vars{"log"}, $$Vars{"size"}, $$Vars{"cache"});

	return undef;
}

sub _chooseRandomImage
{
	my ($dir, $Cache) = @_;
	my $file;
	
	# get a directory listing of all images in given directory
	# remove '.', '..', and all files that aren't gif, png, or jpg
	#
	opendir(IMAGES, $dir);
	my @Files = grep { $_ =~ /\.(gif|png|jpg|jpeg)$/i } readdir(IMAGES);
	closedir(IMAGES);

	my $max = scalar(@Files);
	if($max == 1)
	{
		$file =  "$dir/" . $Files[0];
	}
	elsif($max > 1)
	{
		# randomly choose an image from the given directory
		# call checkCache to ensure that the image hasn't been
		# recently used...
		#
		if($max == scalar @{$Cache})
		{
			$file = $$Cache[0];
			@{$Cache} = splice(@{$Cache}, sprintf("%.0f", scalar(@{$Cache})/2));
		}
		else
		{
			do
			{
				# generate a random number between 0 and max...
				#
				my $rand = rand ($max - 1);
				$rand = sprintf("%.0f", $rand); # round to nearest integer
				$file = "$dir/" . $Files[$rand];
			}
			while(_checkCache($file, $Cache));
		}
	}
	
	return $file;
}

sub _refreshDesktop
{
	my ($file) = @_;

	# call xfdesktop and update image
	#
	system("ln -sf \'$file\' $ENV{HOME}/.xfce4/.desktopImage");
	system("xfdesktop");

	return undef;
}

sub _checkCache
{
	my ($file, $Cache) = @_;

	for(my $i = 0; $i < scalar @{$Cache}; $i++)
	{
		return 1 if $$Cache[$i] eq $file;
	}

	return 0;
}

sub _updateCache
{
	my ($file, $log, $max, $Cache) = @_;
	my $size = scalar @{$Cache};
	
	if($size > $max)
	{
		# shorten cache to equal maximum allowed size
		#
		splice(@{$Cache}, 0, ($size - $max) + 1);
	}
	elsif(scalar $size == $max)
	{
		# remove the 1st list element
		#
		shift(@{$Cache});
	}

	# push new file onto cache list
	#
	push @{$Cache}, $file;

	return undef;
}

